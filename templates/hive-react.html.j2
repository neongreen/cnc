<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hive</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    @font-face {
      font-family: 'MonaspaceKrypton';
      src: url('https://cdn.jsdelivr.net/gh/githubnext/monaspace@v1.000/fonts/webfonts/MonaspaceKrypton-Regular.woff') format('woff');
      font-weight: normal;
      font-style: normal;
    }

    @font-face {
      font-family: 'MonaspaceRadon';
      src: url('https://cdn.jsdelivr.net/gh/githubnext/monaspace@v1.000/fonts/webfonts/MonaspaceRadon-Regular.woff') format('woff');
      font-weight: normal;
      font-style: normal;
    }

    html {
      font-size: 14px;
    }

    body {
      font-family: sans-serif;
      margin: 20px;
    }

    .matchup-table {
      margin-top: 20px;
      margin-bottom: 40px;
      border-collapse: collapse;
      width: auto;
    }

    .matchup-table th,
    .matchup-table td {
      border: 1px solid #ddd;
      padding: 0.5rem;
      text-align: center;
      min-width: 4rem;
    }

    .matchup-table th {
      background-color: #f2f2f2;
      font-weight: bold;
      font-size: 1rem;
    }

    .matchup-table .self-match {
      background-color: #ddd;
      color: #666;
    }

    .matchup-table .no-matches {
      background-color: #f8f9fa;
      color: #6c757d;
    }

    .matchup-table .has-matches {
      background-color: #eff8ff;
      font-family: 'MonaspaceRadon', monospace;
    }

    .matchup-table .highlighted {
      background-color: #fff197;
    }

    .player-link {
      color: #1a73e8;
      text-decoration: none;
      font-weight: 700;
      transition: color 0.2s;
    }

    .player-link:hover {
      color: #0056b3;
      text-decoration: underline;
    }

    .player-link:visited {
      color: #6f42c1;
    }

    .group-header {
      background-color: #f0f0f0;
      font-size: 0.8em;
      color: #666;
      padding: 4px;
    }

    .total-games-header {
      background-color: #f0f0f0;
      font-size: 0.8em;
      color: #666;
      padding: 4px;
    }

    .rated-unrated-header {
      font-size: 0.7em;
      color: gray;
    }

    .unrated-text {
      color: gray;
      font-size: 0.7em;
    }
  </style>
</head>

<body>
  <h1>Hive</h1>
  <p>
    Source on GitHub:
    <a href="https://github.com/neongreen/cnc" target="_blank">neongreen/cnc</a>
  </p>

  <h2>Game counts between players</h2>
  <p>
    This table shows the detailed game statistics between each pair of players.
    The first row shows wins-losses-draws for rated games, the second row shows wins-losses-draws for unrated games.
    Players are sorted by total number of games played, maintaining the order: known players first, then bots, then
    outsiders.
  </p>

  <div id="hive-table-root"></div>

  <script>
    // Embed the table data directly to avoid Jinja2 parsing issues
    window.tableData = {{ table_data | tojson | safe }};
  </script>

  <script type="text/babel">
    const { useState, useEffect } = React;

    function HiveTable({ data }) {
      const [sortConfig, setSortConfig] = useState({ key: null, direction: 'asc' });

      const handleSort = (key) => {
        let direction = 'asc';
        if (sortConfig.key === key && sortConfig.direction === 'asc') {
          direction = 'desc';
        }
        setSortConfig({ key, direction });
      };

      const sortedPlayers = [...data.players].sort((a, b) => {
        if (sortConfig.key === 'total_games') {
          return sortConfig.direction === 'asc'
            ? a.total_games - b.total_games
            : b.total_games - a.total_games;
        }
        return 0;
      });

      const getGroupColor = (group, groupIndex) => {
        const groupColorPalette = [
          "#e3f2fd", "#c8e6c9", "#fff9c4", "#fce4ec", "#f3e5f5",
          "#fff3e0", "#e0f2f1", "#fff8e1", "#e8eaf6", "#e0f7fa"
        ];

        if (group === "(outsider)") {
          return "#f5f5f5";
        }

        try {
          const configIndex = data.config.group_order.indexOf(group);
          return groupColorPalette[configIndex % groupColorPalette.length];
        } catch {
          return "#f5f5f5";
        }
      };

      const renderGroupHeaders = () => {
        const maxGroups = Math.max(...data.players.map(p => p.groups.length));

        return Array.from({ length: maxGroups }, (_, groupLevel) => (
          <tr key={`group-${groupLevel}`}>
            <th></th>
            {sortedPlayers.map((player, colIndex) => {
              const groups = player.groups;
              if (groupLevel < groups.length) {
                const group = groups[groupLevel];
                const bgColor = getGroupColor(group, groupLevel);
                return (
                  <th
                    key={`${player.id}-group-${groupLevel}`}
                    style={{ backgroundColor: bgColor }}
                    className="group-header"
                  >
                    {group !== "(outsider)" ? group : ""}
                  </th>
                );
              } else {
                return (
                  <th
                    key={`${player.id}-empty-${groupLevel}`}
                    style={{ backgroundColor: "#f5f5f5" }}
                    className="group-header"
                  >
                    &nbsp;
                  </th>
                );
              }
            })}
          </tr>
        ));
      };

      const renderGameCell = (rowPlayer, colPlayer) => {
        if (rowPlayer.id === colPlayer.id) {
          return <td key={`${rowPlayer.id}-${colPlayer.id}`} className="self-match"></td>;
        }

        const matchup = data.game_stats.find(
          stat =>
            (stat.player1 === rowPlayer.id && stat.player2 === colPlayer.id) ||
            (stat.player1 === colPlayer.id && stat.player2 === rowPlayer.id)
        );

        if (!matchup) {
          return <td key={`${rowPlayer.id}-${colPlayer.id}`} className="no-matches"></td>;
        }

        const isRowPlayerFirst = matchup.player1 === rowPlayer.id;
        const ratedStats = matchup.rated_stats;
        const unratedStats = matchup.unrated_stats;

        const getCellClass = () => {
          let className = "has-matches";

          const rowHighlightGroups = rowPlayer.groups.filter(g =>
            data.config.highlight_games.includes(g)
          );
          const colHighlightGroups = colPlayer.groups.filter(g =>
            data.config.highlight_games.includes(g)
          );

          if (rowHighlightGroups.length > 0 && colHighlightGroups.length > 0) {
            className += " highlighted";
          }

          if (ratedStats.total === 0 && unratedStats.total === 0) {
            className = "no-matches";
          }

          return className;
        };

        const formatStats = (stats) => {
          if (stats.total === 0) return "&nbsp;";
          let text = `${stats.wins}-${stats.losses}`;
          if (stats.draws > 0) text += `-${stats.draws}`;
          return text;
        };

        return (
          <td key={`${rowPlayer.id}-${colPlayer.id}`} className={getCellClass()}>
            <span dangerouslySetInnerHTML={{ __html: formatStats(ratedStats) }}></span>
            <br />
            <span className="unrated-text" dangerouslySetInnerHTML={{ __html: formatStats(unratedStats) }}></span>
          </td>
        );
      };

      return (
        <table className="matchup-table">
          <thead>
            {/* Total Games Row */}
            <tr>
              <th className="total-games-header">Total Games</th>
              {sortedPlayers.map(player => (
                <th key={`total-${player.id}`} className="total-games-header">
                  {player.total_games}
                </th>
              ))}
            </tr>

            {/* Player Names Row */}
            <tr>
              <th>
                <span>rated,</span>
                <span className="rated-unrated-header">unrated</span>
              </th>
              {sortedPlayers.map(player => {
                const hivegameNick = player.hivegame_nick.startsWith("HG#")
                  ? player.hivegame_nick.slice(3)
                  : player.hivegame_nick;

                return (
                  <th key={`name-${player.id}`}>
                    <a
                      href={`https://hivegame.com/@/${hivegameNick}`}
                      target="_blank"
                      className="player-link"
                    >
                      {player.display_name}
                    </a>
                  </th>
                );
              })}
            </tr>

            {/* Group Headers */}
            {renderGroupHeaders()}
          </thead>

          <tbody>
            {sortedPlayers.map(rowPlayer => {
              const hivegameNick = rowPlayer.hivegame_nick.startsWith("HG#")
                ? rowPlayer.hivegame_nick.slice(3)
                : rowPlayer.hivegame_nick;

              return (
                <tr key={`row-${rowPlayer.id}`}>
                  <th>
                    <a
                      href={`https://hivegame.com/@/${hivegameNick}`}
                      target="_blank"
                      className="player-link"
                    >
                      {rowPlayer.display_name}
                    </a>
                  </th>
                  {sortedPlayers.map(colPlayer => renderGameCell(rowPlayer, colPlayer))}
                </tr>
              );
            })}
          </tbody>
        </table>
      );
    }

    function App() {
      const [data, setData] = useState(null);
      const [loading, setLoading] = useState(true);
      const [error, setError] = useState(null);

      useEffect(() => {
        try {
          const tableData = window.tableData;
          setData(tableData);
        } catch (err) {
          setError(err.message);
        } finally {
          setLoading(false);
        }
      }, []);

      if (loading) {
        return <div>Loading...</div>;
      }

      if (error) {
        return <div>Error: {error}</div>;
      }

      if (!data) {
        return <div>No data available</div>;
      }

      return <HiveTable data={data} />;
    }

    ReactDOM.render(<App />, document.getElementById('hive-table-root'));
  </script>
</body>

</html>